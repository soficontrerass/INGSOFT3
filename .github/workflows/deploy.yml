name: Deploy TP5 to Cloud Run

on:
  push:
    branches: [ main ]
    paths:
      - 'TP5/**'
  workflow_dispatch: {}

env:
  REPO: tp5-repo
  PROJECT: ${{ secrets.GCP_PROJECT_ID }}
  REGION: ${{ secrets.GCP_REGION }}
  SHA: ${{ github.sha }}

jobs:
  # Job: construye imágenes (server + client) y las sube al Artifact Registry / Container Registry
  build:
    name: Build & push images (QA credentials)
    runs-on: ubuntu-latest
    environment: qa
    steps:
      # Clona repo
      - name: Checkout
        uses: actions/checkout@v4

      # Verifica que la secret de QA esté disponible en el runner
      - name: Debug - verify qa secret available
        env:
          GCP_SA_KEY_QA: ${{ secrets.GCP_SA_KEY_QA }}
        run: |
          if [ -z "$GCP_SA_KEY_QA" ]; then
            echo "ERROR: GCP_SA_KEY_QA is empty or not available in this job"; exit 1
          else
            echo "GCP_SA_KEY_QA is present (len=$(printf '%s' "$GCP_SA_KEY_QA" | wc -c))"
          fi

      # Autentica el runner contra GCP usando la service account (QA)
      - name: Authenticate to GCP (build)
        uses: google-github-actions/auth@v1
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY_QA }}

      # Instala / configura gcloud CLI en el runner
      - name: Setup gcloud CLI
        uses: google-github-actions/setup-gcloud@v1
        with:
          project_id: ${{ secrets.GCP_PROJECT_ID }}
          version: 'latest'

      # Asegura que las APIs necesarias de GCP estén habilitadas
      - name: Ensure required GCP APIs enabled
        run: |
          gcloud services enable sql-component.googleapis.com sqladmin.googleapis.com cloudbuild.googleapis.com artifactregistry.googleapis.com --project="${{ secrets.GCP_PROJECT_ID }}" --quiet || true
          sleep 5

      # Build y submit de la imagen del servidor usando Cloud Build
      - name: Build & push server image
        run: |
          SERVER_IMAGE="${REGION}-docker.pkg.dev/${PROJECT}/${REPO}/tp5-server:${SHA}"
          echo "Building and pushing ${SERVER_IMAGE}"
          gcloud builds submit TP5/server --tag "${SERVER_IMAGE}" --project "$PROJECT" --region "$REGION"

      # Guarda referencias de imágenes en archivos (para uso posterior en deploy)
      - name: Save image references
        run: |
          echo "${REGION}-docker.pkg.dev/${PROJECT}/${REPO}/tp5-server:${SHA}" > image-ref-server.txt
          echo "${REGION}-docker.pkg.dev/${PROJECT}/${REPO}/tp5-client:${SHA}" > image-ref-client.txt

      # Sube los archivos con las referencias de imágenes como artifact
      - name: Upload image references artifact
        uses: actions/upload-artifact@v4
        with:
          name: image-refs
          path: |
            image-ref-server.txt
            image-ref-client.txt

      # Intenta obtener la URL del servicio server (si ya existe) para inyectarla en el build del cliente
      - name: Get server URL (temporary, may be empty on first run)
        id: get-server
        run: |
          SERVER_URL=$(gcloud run services describe tp5-server-qa --region "$REGION" --project "$PROJECT" --format='value(status.url)' || echo "")
          echo "SERVER_URL=$SERVER_URL" >> $GITHUB_OUTPUT

      # Build y push de la imagen del cliente; inyecta VITE_API_URL si SERVER_URL disponible
      - name: Build & push client image
        run: |
          CLIENT_IMAGE="${REGION}-docker.pkg.dev/${PROJECT}/${REPO}/tp5-client:${SHA}"
          echo "Building client image ${CLIENT_IMAGE} with API=${{ steps.get-server.outputs.SERVER_URL }}"
          gcloud auth configure-docker "${REGION}-docker.pkg.dev" --quiet
          # If SERVER_URL is empty, the client will be built with an empty VITE_API_URL;
          # deploy-qa will redeploy client with correct env if needed.
          docker build --build-arg VITE_API_URL="${{ steps.get-server.outputs.SERVER_URL }}" -t "${CLIENT_IMAGE}" TP5/client
          docker push "${CLIENT_IMAGE}"
        env:
          CLOUDSDK_CORE_DISABLE_PROMPTS: "1"

  # Job: despliega automáticamente a QA, corre migraciones y smoke tests; rollback en fallo
  deploy-qa:
    name: Deploy to QA (automatic)
    needs: build
    runs-on: ubuntu-latest
    environment: qa
    steps:
      # Clona repo
      - name: Checkout
        uses: actions/checkout@v4

      # Verifica presencia de secret QA
      - name: Debug - verify qa secret available
        env:
          GCP_SA_KEY_QA: ${{ secrets.GCP_SA_KEY_QA }}
        run: |
          if [ -z "$GCP_SA_KEY_QA" ]; then
            echo "ERROR: GCP_SA_KEY_QA is empty or not available in this job"; exit 1
          else
            echo "GCP_SA_KEY_QA is present"
          fi

      # Autenticación QA
      - name: Authenticate to GCP (QA)
        uses: google-github-actions/auth@v1
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY_QA }}

      # Instala gcloud
      - name: Setup gcloud CLI (QA)
        uses: google-github-actions/setup-gcloud@v1
        with:
          project_id: ${{ secrets.GCP_PROJECT_ID }}
          version: 'latest'

      # Asegura APIs
      - name: Ensure required GCP APIs enabled
        run: |
          gcloud services enable sql-component.googleapis.com sqladmin.googleapis.com cloudbuild.googleapis.com artifactregistry.googleapis.com --project="${{ secrets.GCP_PROJECT_ID }}" --quiet || true
          sleep 5

      # Guarda la imagen previa del server para permitir rollback si falla el despliegue
      - name: Record previous server image (QA)
        id: prev_image
        run: |
         PREV=$(gcloud run services describe tp5-server-qa --region "$REGION" --project "$PROJECT" --format='value(spec.template.spec.containers[0].image)' || true)
          echo "PREV_IMAGE=$PREV" >> $GITHUB_ENV
          echo "Prev image: $PREV"

      # Despliega la imagen del server a Cloud Run conectada a Cloud SQL (QA)
      - name: Deploy server QA (with Cloud SQL)
        run: |
          IMAGE="${REGION}-docker.pkg.dev/${PROJECT}/${REPO}/tp5-server:${SHA}"
          INSTANCE_CONN_NAME="${{ secrets.INSTANCE_CONN_NAME_QA }}"
          DB_USER="postgres"
          DB_NAME="${{ secrets.DB_NAME_QA }}"
          gcloud run deploy tp5-server-qa \
            --image "${IMAGE}" \
            --region "${REGION}" \
            --platform managed \
            --allow-unauthenticated \
            --add-cloudsql-instances "${INSTANCE_CONN_NAME}" \
            --set-env-vars DB_HOST="/cloudsql/${INSTANCE_CONN_NAME}",DB_USER="${DB_USER}",DB_PASS="${{ secrets.DB_PASS_QA }}",DB_NAME="${DB_NAME}" \
            --project "$PROJECT" --quiet

      # Crea/ejecuta job de migraciones en Cloud Run (idempotente) y espera a que termine
      - name: Run DB migrations (QA) as Cloud Run Job
        run: |
          IMAGE="${REGION}-docker.pkg.dev/${PROJECT}/${REPO}/tp5-server:${SHA}"
          JOB_NAME="tp5-migrate-qa"
          INSTANCE_CONN_NAME="${{ secrets.INSTANCE_CONN_NAME_QA }}"
          # create or update job (idempotent)
          if ! gcloud run jobs describe ${JOB_NAME} --region ${REGION} --project ${PROJECT} >/dev/null 2>&1; then
            gcloud run jobs create ${JOB_NAME} \
              --image "${IMAGE}" \
              --region "${REGION}" \
              --command node --args dist/migrate.js \
              --set-cloudsql-instances "${INSTANCE_CONN_NAME}" \
              --set-env-vars DB_HOST="/cloudsql/${INSTANCE_CONN_NAME}",DB_USER="postgres",DB_PASS="${{ secrets.DB_PASS_QA }}",DB_NAME="${{ secrets.DB_NAME_QA }}" \
              --project "${PROJECT}"
          else
            gcloud run jobs update ${JOB_NAME} \
              --image "${IMAGE}" \
              --region "${REGION}" \
              --command node --args dist/migrate.js \
              --set-cloudsql-instances "${INSTANCE_CONN_NAME}" \
              --set-env-vars DB_HOST="/cloudsql/${INSTANCE_CONN_NAME}",DB_USER="postgres",DB_PASS="${{ secrets.DB_PASS_QA }}",DB_NAME="${{ secrets.DB_NAME_QA }}" \
              --project "${PROJECT}" || true
          fi
          # execute job and wait for completion
          gcloud run jobs execute ${JOB_NAME} --region ${REGION} --project ${PROJECT} --wait
        env:
          CLOUDSDK_CORE_DISABLE_PROMPTS: "1"

      # Re-despliega server QA (puede ajustar env vars)
      - name: Deploy server QA
        run: |
          IMAGE="${REGION}-docker.pkg.dev/${PROJECT}/${REPO}/tp5-server:${SHA}"
          gcloud run deploy tp5-server-qa \
            --image "${IMAGE}" \
            --region "${REGION}" \
            --platform managed \
            --allow-unauthenticated \
            --set-env-vars FORECAST_COUNT=5 \
            --project "$PROJECT"

      # Despliega el cliente a Cloud Run (QA) y asegura que VITE_API_URL apunte al server QA
      - name: Deploy client QA (set VITE_API_URL to QA server URL)
        run: |
          IMAGE="${REGION}-docker.pkg.dev/${PROJECT}/${REPO}/tp5-client:${SHA}"
          SERVER_URL=$(gcloud run services describe tp5-server-qa --region "$REGION" --project "$PROJECT" --format='value(status.url)')
          echo "QA server URL: $SERVER_URL"
          # Re-build client locally in runner only if needed to inject API URL into static bundle.
          # Simpler: deploy container image with env var CLIENT_API set for runtime, if client reads env at runtime.
          # Here we set CLIENT_URL env var for server and rely on client having built with correct VITE_API_URL earlier if present.
          gcloud run deploy tp5-client-qa \
            --image "${IMAGE}" \
            --region "${REGION}" \
            --platform managed \
            --allow-unauthenticated \
            --set-env-vars VITE_API_URL="$SERVER_URL" \
            --project "$PROJECT"

      # Smoke test: llama /health con reintentos; el step falla si el endpoint no responde OK
      - name: Smoke test QA
        run: |
          URL=$(gcloud run services describe tp5-server-qa --region "$REGION" --project "$PROJECT" --format='value(status.url)')
          echo "QA server URL: $URL"
          curl --fail --retry 5 --retry-delay 2 "$URL/health"
      
      # Si algún step anterior falló, este bloque intenta hacer rollback usando la imagen previa
      - name: Rollback on failure (QA)
        if: failure()
        run: |
          if [ -z "${PREV_IMAGE}" ]; then
            echo "No previous image found, cannot rollback."; exit 1
          fi
          echo "Rolling back to previous image: ${PREV_IMAGE}"
          gcloud run deploy tp5-server-qa --image "${PREV_IMAGE}" --region "${REGION}" --project "${PROJECT}"

  # Job: despliegue a producción (requiere aprobación a nivel de environment en GH Actions)
  deploy-prod:
    name: Deploy to Production (requires approval)
    needs: deploy-qa
    runs-on: ubuntu-latest
    environment: prod
    steps:
      # Clona repo
      - name: Checkout
        uses: actions/checkout@v4

      # Guarda imagen previa de PROD para permitir rollback
      - name: Record previous server image (PROD)
        id: prev_image_prod
        run: |
          echo "PREV_IMAGE=${{ steps.prev_image_prod_output }}" >> $GITHUB_ENV || true
          echo "PREV_IMAGE=$(gcloud run services describe tp5-server --region ${REGION} --project ${PROJECT} --format='value(spec.template.spec.containers[0].image)')" >> $GITHUB_ENV

      # Guarda revisión previa de PROD
      - name: Record previous revision (PROD)
        id: record_prev_rev
        run: |
          PREV_REVISION=$(gcloud run services describe tp5-server --region ${REGION} --project ${PROJECT} --format='value(status.latestReadyRevisionName)' || echo "")
          echo "PREV_REVISION=$PREV_REVISION" >> $GITHUB_ENV
          echo "PREV_REVISION=$PREV_REVISION"

      # Verifica secret PROD
      - name: Debug - verify prod secret available
        env:
          GCP_SA_KEY_PROD: ${{ secrets.GCP_SA_KEY_PROD }}
        run: |
          if [ -z "$GCP_SA_KEY_PROD" ]; then
            echo "ERROR: GCP_SA_KEY_PROD is empty or not available in this job"; exit 1
          else
            echo "GCP_SA_KEY_PROD is present"
          fi

      # Autenticación PROD
      - name: Authenticate to GCP (PROD)
        uses: google-github-actions/auth@v1
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY_PROD }}

      # Instala gcloud en el runner
      - name: Setup gcloud CLI (PROD)
        uses: google-github-actions/setup-gcloud@v1
        with:
          project_id: ${{ secrets.GCP_PROJECT_ID }}
          version: 'latest'

      # Habilita APIs necesarias
      - name: Ensure required GCP APIs enabled
        run: |
          gcloud services enable sql-component.googleapis.com sqladmin.googleapis.com cloudbuild.googleapis.com artifactregistry.googleapis.com --project="${{ secrets.GCP_PROJECT_ID }}" --quiet || true
          sleep 5

      # Despliega server PROD conectado a Cloud SQL
      - name: Deploy server PROD (with Cloud SQL)
        run: |
          IMAGE="${REGION}-docker.pkg.dev/${PROJECT}/${REPO}/tp5-server:${SHA}"
          INSTANCE_CONN_NAME="${{ secrets.INSTANCE_CONN_NAME_PROD }}"
          DB_USER="postgres"
          DB_NAME="${{ secrets.DB_NAME_PROD }}"
          gcloud run deploy tp5-server \
            --image "${IMAGE}" \
            --region "${REGION}" \
            --platform managed \
            --allow-unauthenticated \
            --add-cloudsql-instances "${INSTANCE_CONN_NAME}" \
            --set-env-vars DB_HOST="/cloudsql/${INSTANCE_CONN_NAME}",DB_USER="${DB_USER}",DB_PASS="${{ secrets.DB_PASS_PROD }}",DB_NAME="${DB_NAME}" \
            --project "$PROJECT" --quiet

      # Realiza despliegue canario (10% tráfico al nuevo revision) para pruebas en producción
      - name: Canary traffic (PROD) - route 10% to new revision
        run: |
          NEW_REVISION=$(gcloud run services describe tp5-server --region ${REGION} --project ${PROJECT} --format='value(status.latestReadyRevisionName)')
          echo "NEW_REVISION=$NEW_REVISION" >> $GITHUB_ENV
          if [ -n "${PREV_REVISION}" ]; then
            gcloud run services update-traffic tp5-server --region ${REGION} --to-revisions ${PREV_REVISION}=90,${NEW_REVISION}=10 --project ${PROJECT}
          else
            echo "No previous revision found; routing to latest (new) revision"
            gcloud run services update-traffic tp5-server --region ${REGION} --to-latest --project ${PROJECT}
          fi

      # Backup DB, ejecutar migraciones y promover si las migraciones pasan; rollback si fallan
      - name: Backup DB, run migrations (PROD) and promote on success
        env:
          PROJECT: ${{ secrets.GCP_PROJECT_ID }}
          REGION: ${{ secrets.GCP_REGION }}
          REPO: ${{ env.REPO }}
          SHA: ${{ env.SHA }}
          INSTANCE_CONN_NAME_PROD: ${{ secrets.INSTANCE_CONN_NAME_PROD }}
          DB_PASS_PROD: ${{ secrets.DB_PASS_PROD }}
          DB_NAME_PROD: ${{ secrets.DB_NAME_PROD }}
          GCS_BACKUP_BUCKET: ${{ secrets.GCS_BACKUP_BUCKET }}
          CLOUDSDK_CORE_DISABLE_PROMPTS: "1"
        run: |
          set -euo pipefail

          IMAGE="${REGION}-docker.pkg.dev/${PROJECT}/${REPO}/tp5-server:${SHA}"
          JOB_NAME="tp5-migrate-prod"

          if [ -z "${INSTANCE_CONN_NAME_PROD:-}" ]; then
            echo "ERROR: INSTANCE_CONN_NAME_PROD is empty"; exit 1
          fi
          if [ -z "${GCS_BACKUP_BUCKET:-}" ]; then
            echo "ERROR: GCS_BACKUP_BUCKET secret is empty"; exit 1
          fi

          INSTANCE_ID=$(echo "$INSTANCE_CONN_NAME_PROD" | awk -F: '{print $NF}')
          BACKUP_FILE="tp5db-prod-$(date +%Y%m%d-%H%M%S).sql.gz"
          echo "Exporting prod DB to gs://${GCS_BACKUP_BUCKET}/${BACKUP_FILE} ..."
          gcloud sql export sql "${INSTANCE_ID}" "gs://${GCS_BACKUP_BUCKET}/${BACKUP_FILE}" --database="${DB_NAME_PROD}" --project="${PROJECT}" --quiet

          echo "Create/update migration job ${JOB_NAME} with Cloud SQL instance ${INSTANCE_CONN_NAME_PROD}..."
          if ! gcloud run jobs describe "${JOB_NAME}" --region "${REGION}" --project "${PROJECT}" >/dev/null 2>&1; then
            gcloud run jobs create "${JOB_NAME}" \
              --image "${IMAGE}" \
              --region "${REGION}" \
              --command node --args dist/migrate.js \
              --set-cloudsql-instances "${INSTANCE_CONN_NAME_PROD}" \
              --set-env-vars "DB_HOST=/cloudsql/${INSTANCE_CONN_NAME_PROD},DB_USER=postgres,DB_PASS=${DB_PASS_PROD},DB_NAME=${DB_NAME_PROD}" \
              --project "${PROJECT}"
          else
            gcloud run jobs update "${JOB_NAME}" \
              --image "${IMAGE}" \
              --region "${REGION}" \
              --command node --args dist/migrate.js \
              --set-cloudsql-instances "${INSTANCE_CONN_NAME_PROD}" \
              --set-env-vars "DB_HOST=/cloudsql/${INSTANCE_CONN_NAME_PROD},DB_USER=postgres,DB_PASS=${DB_PASS_PROD},DB_NAME=${DB_NAME_PROD}" \
              --project "${PROJECT}" || true
          fi

          echo "Executing migration job..."
          set +e
          gcloud run jobs execute "${JOB_NAME}" --region "${REGION}" --project "${PROJECT}" --wait
          JOB_EXIT=$?
          set -e

          if [ $JOB_EXIT -ne 0 ]; then
            echo "Migration job failed (exit=$JOB_EXIT). Fetching logs and attempting rollback..."
            LAST_EXEC=$(gcloud run jobs executions list --job "${JOB_NAME}" --region "${REGION}" --project "${PROJECT}" --limit 1 --format='value(name)')
            gcloud beta run jobs executions logs read "${LAST_EXEC}" --region "${REGION}" --project "${PROJECT}" --limit 500 || true

            if [ -n "${PREV_REVISION:-}" ]; then
              echo "Rolling back to previous revision ${PREV_REVISION}"
              gcloud run services update-traffic tp5-server --region "${REGION}" --to-revisions "${PREV_REVISION}=100" --project "${PROJECT}"
            else
              echo "No PREV_REVISION found; cannot rollback traffic automatically."
            fi
            exit 1
          fi

          echo "Migration job succeeded. Running smoke test..."
          URL=$(gcloud run services describe tp5-server --region "${REGION}" --project "${PROJECT}" --format='value(status.url)')
          echo "Service URL: $URL"
          for i in 1 2 3 4 5; do
            if curl --fail --silent --show-error --retry 0 "$URL/health"; then
              echo "Smoke test ok"
              SMOKE_OK=1
              break
            else
              echo "Smoke test attempt $i failed, sleeping 5s..."
              sleep 5
            fi
          done

          if [ "${SMOKE_OK:-0}" -ne 1 ]; then
            echo "Smoke test failed after migrations. Initiating rollback..."
            if [ -n "${PREV_REVISION:-}" ]; then
              gcloud run services update-traffic tp5-server --region "${REGION}" --to-revisions "${PREV_REVISION}=100" --project "${PROJECT}"
            fi
            exit 1
          fi

          echo "Promoting new revision to 100% traffic..."
          NEW_REV=$(gcloud run services describe tp5-server --region "${REGION}" --project "${PROJECT}" --format='value(status.latestReadyRevisionName)')
          gcloud run services update-traffic tp5-server --region "${REGION}" --to-revisions "${NEW_REV}=100" --project "${PROJECT}"

          echo "Done."

      #imagen del servidor a cloud para producción, configuro la instancia de conexion
      - name: Deploy server PROD
        run: |
          IMAGE="${REGION}-docker.pkg.dev/${PROJECT}/${REPO}/tp5-server:${SHA}"
          gcloud run deploy tp5-server \
            --image "${IMAGE}" \
            --region "${REGION}" \
            --platform managed \
            --allow-unauthenticated \
            --set-env-vars FORECAST_COUNT=10,CLIENT_URL="https://tp5-client-366o626kia-uc.a.run.app" \
            --project "$PROJECT"

      #imagen del cliente a cloud para producción
      - name: Deploy client PROD
        run: |
          IMAGE="${REGION}-docker.pkg.dev/${PROJECT}/${REPO}/tp5-client:${SHA}"
          gcloud run deploy tp5-client \
            --image "${IMAGE}" \
            --region "${REGION}" \
            --platform managed \
            --allow-unauthenticated \
            --set-env-vars VITE_API_URL="https://tp5-server-366o626kia-uc.a.run.app" \
            --project "$PROJECT"

      # Smoke test: llama /health con reintentos; el step falla si el endpoint no responde OK
      - name: Smoke test PROD
        run: |
          URL=$(gcloud run services describe tp5-server --region "$REGION" --project "$PROJECT" --format='value(status.url)')
          echo "PROD server URL: $URL"
          curl --fail --retry 5 --retry-delay 2 "$URL/health"

      #si todo ok, promuevo revision a 100% (trafico)
      - name: Promote new revision to 100% (PROD)
        if: success()
        run: |
          echo "Promoting NEW_REVISION=${NEW_REVISION} to 100%"
          gcloud run services update-traffic tp5-server --region ${REGION} --to-revisions ${NEW_REVISION}=100 --project ${PROJECT}

      #se ejecuta solo si algun paso anterior paso, intenta revertir el 100% a la revision previa
      - name: Rollback to previous revision (PROD)
        if: failure()
        run: |
          if [ -n "${PREV_REVISION}" ]; then
            echo "Rolling back to previous revision ${PREV_REVISION}"
            gcloud run services update-traffic tp5-server --region ${REGION} --to-revisions ${PREV_REVISION}=100 --project ${PROJECT}
          else
            echo "No previous revision available to rollback; skipping."
            exit 0
          fi
          BACKUP_FILE="tp5db-prod-$(date +%Y%m%d-%H%M%S).sql.gz"
          echo "Exporting prod DB to gs://${GCS_BACKUP_BUCKET}/${BACKUP_FILE} ..."
          gcloud sql export sql "${INSTANCE_ID}" "gs://${GCS_BACKUP_BUCKET}/${BACKUP_FILE}" --database="${DB_NAME_PROD}" --project="${PROJECT}" --quiet

          # Save backup filename for artifact (small pointer)
          echo "${BACKUP_FILE}" > backup-file.txt
          # optionally save migration job output to a file from the commands above (use tee in runtime)
          # echo "migration logs saved to migration-log.txt" (generate that file where you run the job)

      #esta func y la sig:
      #sube el nombre del archvio de buckup y los logs de la migracion como artefactos
      - name: Upload backup metadata artifact
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: prod-db-backup-metadata
          path: backup-file.txt

      - name: Upload migration logs artifact (if exists)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: migrate-logs
          path: migration-log.txt