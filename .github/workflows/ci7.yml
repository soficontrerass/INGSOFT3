name: CI7 - tests, coverage, SonarCloud, Cypress

on:
  push:
    branches: [ main, master, restore-c55075c2 ]
    paths:
      - 'TP7/**'
      - '.github/workflows/ci7.yml'
  pull_request:
    branches: [ main ]
    paths:
      - 'TP7/**'
      - '.github/workflows/ci7.yml'
  workflow_dispatch: {}

jobs:
  ci:
    # Ejecutar en un runner Ubuntu
    runs-on: ubuntu-latest

    # Variables de entorno del job (versión Node y umbral de coverage)
    env:
      NODE_VERSION: '20'
      COVERAGE_THRESHOLD: 70

    steps:
      # Clonar el repositorio para disponer del código en el runner
      - name: Checkout repository
        uses: actions/checkout@v4

      # Instalar Node.js en la versión indicada
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      # Mostrar versiones de node/npm (útil para debug en logs)
      - name: Show node & npm versions (debug)
        run: |
          node -v
          npm -v
          pnpm -v || true

      # Instalar dependencias del servidor (backend)
      - name: Install server dependencies
        run: |
          cd TP7/server
          npm ci

      # Ejecutar tests unitarios del servidor y generar cobertura
      - name: Run server tests (Jest + coverage)
        run: |
          cd TP7/server
          npm run test:ci

      # Subir el reporte de coverage del servidor como artifact
      - name: Upload server coverage artifact
        uses: actions/upload-artifact@v4
        with:
          name: server-coverage
          path: TP7/server/coverage

      # Instalar dependencias del cliente (frontend)
      - name: Install client dependencies
        run: |
          cd TP7/client
          npm ci

      # Ejecutar tests del cliente (Vitest u otra herramienta) y generar coverage
      - name: Run client tests (Vitest + coverage)
        run: |
          cd TP7/client
          npm run test:ci

      # Subir el reporte de coverage del cliente como artifact
      - name: Upload client coverage artifact
        uses: actions/upload-artifact@v4
        with:
          name: client-coverage
          path: TP7/client/coverage

      # Normalizar rutas en archivos lcov para SonarCloud (reemplaza backslashes y prefija paths)
      - name: Normalize & Debug LCOV for Sonar (client + server)
        run: |
          set -e
          echo "=== Normalize client LCOV ==="
          if [ -f TP7/client/coverage/lcov.info ]; then
            # convertir backslashes a slashes
            sed -i 's#\\#/#g' TP7/client/coverage/lcov.info || true

            # prefijar solo si no empieza ya con client/
            awk 'BEGIN{FS=OFS=""} /^SF:/ {
                if ($0 !~ /^SF:client\//) {
                  sub(/^SF:(\.\/*)?/, "SF:client/");
                }
            }
            {print}' TP7/client/coverage/lcov.info > /tmp/client_lcov.tmp && mv /tmp/client_lcov.tmp TP7/client/coverage/lcov.info || true

            echo "Client LCOV head (first 80 lines):"
            head -n 80 TP7/client/coverage/lcov.info || true
            echo "Client SF count:"
            grep -c '^SF:' TP7/client/coverage/lcov.info || true
            echo "Client total DA lines (covered entries):"
            grep '^DA:' TP7/client/coverage/lcov.info | wc -l || true
          else
            echo "TP7/client/coverage/lcov.info not found"
          fi

          echo "=== Normalize server LCOV ==="
          if [ -f TP7/server/coverage/lcov.info ]; then
            sed -i 's#\\#/#g' TP7/server/coverage/lcov.info || true

            awk 'BEGIN{FS=OFS=""} /^SF:/ {
                if ($0 !~ /^SF:server\//) {
                  sub(/^SF:(\.\/*)?/, "SF:server/");
                }
            }
            {print}' TP7/server/coverage/lcov.info > /tmp/server_lcov.tmp && mv /tmp/server_lcov.tmp TP7/server/coverage/lcov.info || true

            echo "Server LCOV head (first 80 lines):"
            head -n 80 TP7/server/coverage/lcov.info || true
            echo "Server SF count:"
            grep -c '^SF:' TP7/server/coverage/lcov.info || true
            echo "Server total DA lines (covered entries):"
            grep '^DA:' TP7/server/coverage/lcov.info | wc -l || true
          else
            echo "TP7/server/coverage/lcov.info not found"
          fi

      # Comprobar umbrales de coverage definidos en la herramienta local (script JS)
      - name: Check coverage thresholds (server & client)
        run: node TP7/tools/check-coverage.js

      - name: Install & test (server)
        working-directory: TP7/server
        run: |
          npm ci
          npm run test:ci   # debe generar server/coverage/lcov.info

      - name: Install & test (client)
        working-directory: TP7/client
        run: |
          npm ci
          npm run test:ci   # debe generar client/coverage/lcov.info

      - name: Debug list TP7 files
        run: |
          echo "PWD: $PWD"
          echo "=== tree TP7 (max depth 3) ==="
          ls -la TP7 || true
          echo "=== server coverage ==="
          if [ -f TP7/server/coverage/lcov.info ]; then
            echo "server lcov exists:" && ls -lh TP7/server/coverage/lcov.info
            echo "first lines:" && sed -n '1,20p' TP7/server/coverage/lcov.info
          else
            echo "server lcov NOT FOUND"
          fi
          echo "=== client coverage ==="
          if [ -f TP7/client/coverage/lcov.info ]; then
            echo "client lcov exists:" && ls -lh TP7/client/coverage/lcov.info
            echo "first lines:" && sed -n '1,20p' TP7/client/coverage/lcov.info
          else
            echo "client lcov NOT FOUND"
          fi
        shell: bash

      - name: Debug print Sonar args env
        run: |
          echo "SONAR_PROJECT_KEY=${{ secrets.SONAR_PROJECT_KEY }}"
          echo "SONAR_ORGANIZATION=${{ secrets.SONAR_ORGANIZATION }}"
          echo "projectBaseDir=TP7"
          echo "args:"
          echo "-Dsonar.javascript.lcov.reportPaths=server/coverage/lcov.info,client/coverage/lcov.info"
        shell: bash


      # Ejecutar SonarCloud scan (envía fuentes y paths de lcov)
      - name: SonarCloud Scan
        uses: sonarsource/sonarcloud-github-action@v2
        with:
          projectBaseDir: TP7
          args: >-
            -Dsonar.projectKey=${{ secrets.SONAR_PROJECT_KEY }}
            -Dsonar.organization=${{ secrets.SONAR_ORGANIZATION }}
            -Dsonar.login=${{ secrets.SONAR_TOKEN }}
            -Dsonar.branch.name=${{ github.ref_name }}
            -Dsonar.sources=server/src,client/src
            -Dsonar.javascript.lcov.reportPaths=server/coverage/lcov.info,client/coverage/lcov.info
            -X
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}

      # Consultar el Quality Gate de SonarCloud y fallar si no es OK
      - name: Check SonarCloud Quality Gate
        if: always()
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
          SONAR_PROJECT_KEY: ${{ secrets.SONAR_PROJECT_KEY }}
        run: |
          set -e
          echo "Checking SonarCloud Quality Gate for $SONAR_PROJECT_KEY"
          sudo apt-get update -y
          sudo apt-get install -y jq curl
          MAX_ATTEMPTS=12
          SLEEP_SEC=5
          attempt=0
          status=""
          resp=""
          while [ $attempt -lt $MAX_ATTEMPTS ]; do
            attempt=$((attempt+1))
            echo "Attempt $attempt/$MAX_ATTEMPTS..."
            resp=$(curl -s -u "$SONAR_TOKEN:" "https://sonarcloud.io/api/qualitygates/project_status?projectKey=${SONAR_PROJECT_KEY}")
            echo "raw response: $resp"
            status=$(echo "$resp" | jq -r '.projectStatus.status' 2>/dev/null || echo "")
            if [ "$status" = "OK" ] || [ "$status" = "ERROR" ]; then
              break
            fi
            sleep $SLEEP_SEC
          done
          echo "SonarCloud quality gate status: '$status'"
          if [ "$status" != "OK" ]; then
            echo "Quality Gate NOT OK. Response:"
            echo "$resp"
            exit 1
          fi

      # Compilar el cliente para pruebas E2E (genera dist)
      - name: Install client deps & build
        run: |
          CLIENT_DIR="client"
          [ -d "TP7/client" ] && CLIENT_DIR="TP7/client"
          if [ -f "${CLIENT_DIR}/package-lock.json" ]; then
            npm --prefix "${CLIENT_DIR}" ci
          else
            npm --prefix "${CLIENT_DIR}" install
          fi
          npm --prefix "${CLIENT_DIR}" run build

      # Servir el build del cliente en el runner en el puerto 8080 (para Cypress)
      - name: Serve client dist on :8080 (background)
        run: |
          CLIENT_DIR="client"
          [ -d "TP7/client" ] && CLIENT_DIR="TP7/client"
          npm --prefix "${CLIENT_DIR}" i -g http-server || true
          npx http-server "${CLIENT_DIR}/dist" -p 8080 & echo $! > "${CLIENT_DIR}/http-server.pid"

      # Esperar a que el servidor http del cliente esté listo
      - name: Wait for client on :8080
        run: npx wait-on http://localhost:8080

      # Ejecutar tests E2E de Cypress contra el cliente servido localmente
      - name: Run Cypress tests (run from client folder)
        run: npx cypress run --config baseUrl=http://localhost:8080 --spec "cypress/e2e/*.cy.js"
        working-directory: TP7/client

      # Iniciar backend en background para las pruebas E2E (si es necesario)
      - name: Start backend for E2E
        run: |
          cd TP7/server
          npm run start &>/dev/null & echo $! > server.pid
        continue-on-error: false

      # Instalar dependencias del cliente específicamente para Cypress
      - name: Install client dependencies for Cypress
        run: npm ci --prefix TP7/client

      # Ejecutar Cypress E2E usando la acción oficial (usa el cliente servido en localhost)
      - name: Run Cypress E2E tests
        uses: cypress-io/github-action@v6
        with:
          working-directory: TP7/client
          wait-on: 'http://localhost:8080'
          wait-on-timeout: 60
          browser: chrome
          record: false

      # Parar el backend iniciado para E2E (si existe), paso ejecutado siempre
      - name: Stop backend
        if: always()
        run: |
          if [ -f TP7/server/server.pid ]; then kill $(cat TP7/server/server.pid) || true; rm -f TP7/server/server.pid; fi

      # Subir resultados de Cypress (screenshots, videos, reports) como artifacts
      - name: Upload Cypress results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: cypress-results
          path: |
            TP7/client/cypress/results
            TP7/client/cypress/videos
            TP7/client/cypress/screenshots

      # Mensaje final de estado del pipeline
      - name: Final status
        run: echo "CI7 pipeline completed"